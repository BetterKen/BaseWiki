# 4 进程间通信

　　每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以**进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）**

![](http://base422.oss-cn-beijing.aliyuncs.com/sysconnect.png)

## 4.1 进程通信的方式

- **pipe管道**
- **fifo管道**
- **内存共享映射**
- **socket(后面会细说)**

## 4.2 pipe管道

管道是一种最基本的IPC机制，**管道作用于有血缘关系的进程之间,通过fork来传递**

由pipe函数创建：

```c
#include <unistd.h>
int pipe(int filedes[2]);
```

**pipe函数调用成功返回0，调用失败返 -1。**

调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，**filedes[0]指向管道的读端，filedes[1]指向管道的写端**(很好记，就像0是标准输入1是标准输出一样) 。所以管道 在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。

### 4.2.1 通信步骤

![](http://base422.oss-cn-beijing.aliyuncs.com/syspipe.png)

1. 父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。
2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。
3. **父进程关闭管道读端，子进程关闭管道写端**。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。

### 4.2.2 demo

```c
#include <stdlib.h>
#include <unistd.h>
#define MAXLINE 80
int main(void)
{
    int n;
    int fd[2];
    pid_t pid;
    char line[MAXLINE];
    if (pipe(fd) < 0) {
        perror("pipe");
        exit(1);
    }
    if ((pid = fork()) < 0) {
        perror("fork");
        exit(1);
    }
    if (pid > 0) { /* parent */
        close(fd[0]);
        write(fd[1], "hello world\n", 12);
        wait(NULL);
    } else { /* child */
        close(fd[1]);
        n = read(fd[0], line, MAXLINE);
        write(STDOUT_FILENO, line, n);
    }
    return 0;
}
```

### 4.2.3 使用限制

**两个进程通过一个管道只能实现单向通信**，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，**就必须另开一个管道**。



### 4.2.4 特殊情况

**使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：**

- 如果所有指向管道写端的文件描述符都关闭了（**管道写端的引用计数等于0**），**而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样**。
- 如果有指向管道写端的文件描述符没关闭（**管道写端的引用计数大于0**），而持**有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞**，直到管道中有数据可读了才读取数据并返回。
- 如果所有指向管道读端的文件描述符都关闭了（**管道读端的引用计数等于0**），**这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止**。讲信号时会讲到怎样使SIGPIPE信号不终止进程。
- 如果有指向管道读端的文件描述符没关闭（**管道读端的引用计数大于0**），而**持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞**，直到管道中有空位置了才写入数据并返回。



